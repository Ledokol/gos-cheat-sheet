\section{Комбинаторные алгоритмы}
\subsection{Минимальный остов}
Пусть $G = (V,E,c)$ — связный взвешенный неориентированный граф. Под весом $c(H)$ произвольного ненулевого подграфа $H$ будем понимать сумму весов всех ребер подграфа $H$.
Остовом называется ацикличный подграф данного графа, содержащий все его вершины.
Ацикличный остовный подграф (содержащий все вершины графа $G$) будем называть остовным лесом графа $G$.
Остов T называется минимальным, если для любого остова $T'$ выполняется неравенство $c(T) \le  c(T')$.
\subsubsection{Алгоритм Борувки–Краскала}
\begin{enumerate}
	\item Сортируем ребра графа по возрастанию весов.
    \item Тривиальный лес объявить растущим.
    \item Проходим ребра в «отсортированном» порядке.
    \item Для каждого ребра выполняем: \begin{itemize}
    	\item если вершины, соединяемые данным ребром лежат в разных деревьях растущего леса, то объединяем эти деревья в одно, а ребро добавляем к строящемуся остову.
    	\item если вершины, соединяемые данным ребром лежат в одном дереве растущего леса, то исключаем ребро из рассмотрения
    	
    	\end{itemize}
    \item Если есть еще нерассмотренные ребра и не все деревья объединены в одно, то переходим к шагу 3, иначе выход.
\end{enumerate}

\subsubsection{Ярника–Прима–Дейкстры}
\begin{enumerate}
	\item Выбирается произвольная вершина — она будет корнем остовного дерева.
	\item Измеряется расстояние от нее до всех внешних по отношению к растущему дереву вершин (расстояние от внешней вершины до ближайшей к ней вершины дерева).
	\item До тех пор пока в дерево не добавлены все вершины делать: \begin{itemize}
		\item Найти вершину, расстояние от дерева до которой минимально.
		\item Добавить ее к дереву.
		\item Пересчитать расстояния от вершин до дерева следующим образом: если расстояние до какой–либо вершины из новой вершины меньше текущего расстояния от дерева, то старое расстояние от дерева заменить новым.
	\end{itemize}
\end{enumerate}

\subsection{Пути в сетях}

Взвешенный орграф $G = (V , E , c )$ называется сетью. 

Пусть $P$ — некоторый $(v,w)$–путь:
\begin{equation}
	v = v_0 \xrightarrow{e_1} v_1 \xrightarrow{e_2} \dots \xrightarrow{e_k} v_k = w
\end{equation}

Величину $c(P)$ назовем длиной пути $P$:
\begin{equation}
	c (P ) = c (e_1 ) + c (e_2 ) + \dots + c (e_k )
\end{equation}

Наименьшую из длин $(v,w)$–путей назовем расстоянием от $v$ до $w$, . . . а тот $(v , w )$ –путь, длина которого равна расстоянию от $v$ до $w$ , будем называть кратчайшим $(v,w)$–путем.

\subsubsection{Алгоритм Форда–Беллмана}
Поиска кратчайшего $(s,t)$ пути, работает на ребрах с \textbf{отрицательными весами}

$D[v]$ — массив, в котором будет «накапливаться» расстояние от выделенной вершины $s$ до всех остальных вершин графа;

 ПРЕДШ$[v]$ — массив, в котором на месте $v$ будет храниться номер вершины–предшественницы вершины $v$ в кратчайшем $(s,v)$– маршруте
 
\begin{enumerate}
	\item Для всех вершин $v \in V$ положить: \begin{itemize}
		\item $D[v] := c(s, v)$;
		\item если $ c(s,v) < \infty$ ПРЕДШ$[v] := s$;
		\item иначе ПРЕДШ$[v] := 0$;
	\end{itemize}
	\item Следующую операцию повторить $n − 2$ раза: \begin{itemize}
		\item для всех вершин $v \in V \setminus \{s\}$:\\ $D[v]:=min\{D[v],D[w]+c[w,v]|w \in V\}$
		\item ПРЕДШ$[v] := w∗$(та вершина, которая обеспечила минимум $D[v]$)
	\end{itemize}
\end{enumerate}

\subsubsection{Алгоритм Дейкстры}
Жадный, не будет работать если есть ребра с отрицательным весом.

$F$ — множество еще не просмотренных вершин.

\begin{enumerate}
	\item $D[s] := 0$;ПРЕДШ$[s] := 0;F := V\setminus\{s\}$
	\item для всех $v \in F$ положим: \begin{itemize}
		\item $D[v] := c[s, v];$
		\item ПРЕДШ$[v] := s;$
	\end{itemize}
	\item $n−1$ раз делать: \begin{itemize}
		\item выбрать $w \in  F : D[w] = min\{D[u]|u \in F\};F := F\setminus{w};$
		\item для всех $v \in F$ делать: \\ если $(D [w ] + c [w , v ] < D [v ])$,\\ то $D [v ] := D [w ] + c [w , v ]$; ПРЕДШ$[v] := w$.
		
	\end{itemize}
\end{enumerate}

\subsection{Потоки в сетях}

Потоком в сети $G$ называется функция $f : E \rightarrow R$, удовлетворяющая условиям:
\begin{itemize}
	\item $0 \le f (e) \le c(e)$ для всех $e \in E$;
	\item $f (v −) = f (v +)$ для всех $v \in V \setminus \{s , t \}$
\end{itemize}
Здесь $f(v−)=\Sigma_{w \in v−}   f(w,v)$, а$f(v+)=\Sigma_{w \in v+}   f(v,w)$.


Пусть $P$ — цепь из $v$ в $w$. Для каждой дуги $e$ цепи $P$ положим
\begin{equation}
	h(e) = \begin{cases} c(e) − f (e) , & \mbox{если e — прямая дуга} \\ f (e), & \mbox{если e — прямая дуга} \end{cases}
\end{equation}

Пусть $h(P) = min\{h(e)|e \in  P\}$.

Цепь $P$ из $v$ в $w$ называется $f$ –дополняющей, если $h(P) > 0$.

\subsubsection{Алгоритм Форда–Фалкерсона}

\begin{enumerate}
	\item Положить $f (e) = 0$ для всех дуг $e \in E$;
	\item для текущего потока $f$ искать f –дополняющую $(s, t)$–цепь;
	\item если такая цепь $P$ построена, то для всех дуг цепи $P$ положить: \begin{equation}
		f(e) = \begin{cases} f (e) + h(P) , & \mbox{для прямых дуг} \\ f (e) - h(P), & \mbox{для обратных дуг} \end{cases}
	\end{equation}
	и вернулся на шаг 2;
	\item иначе СТОП.
\end{enumerate}


\subsection{Парасочетания в двудольных графах}
Паросочетанием в графе называется произвольное множество его ребер такое, что каждая вершина графа инцидентна не более, чем одному ребру из этого множества.

Граф $G = (V,E)$ называется двудольным, если множество его вершин V можно разбить на непересекающиеся множества $X$ и $Y$ такие, что каждое ребро $e \in  E$ имеет вид $e = xy$, где $x \in  X$, $y \in Y$.

Вершины, не принадлежащие ни одному ребру из паросочетания, называют \textbf{свободными относительно $M$} или просто \textbf{свободными}, а все прочие~--- \textbf{насыщенными}.

Удобно также все ребра, входящие в паросочетание $M$ называть \textbf{$M$--темными} или просто \textbf{темными}, а все прочие~--- \textbf{$M$--светлыми} или просто \textbf{светлыми}.

Паросочетание, содержащее наибольшее число ребер, называется наибольшим.

Паросочетание, насыщающее все вершины двудольного графа, называется полным.

Паросочетание, не содержащееся ни в каком другом паросочетании, называется \textbf{максимальным} (по включению).

Пусть $M$~--- паросочетание в графе $G$. \textbf{$M$--чередующейся цепью} называется такая последовательность вершин и ребер вида 
$$
 x_0,\quad x_0y_1,\quad y_1,\quad y_1x_2,\quad x_2,\quad \ldots,\quad x_k,\quad x_ky_{k+1},\quad y_{k+1}, 
 $$
 где $k > 0$, что все вершины этой цепи различны, $x_0$ и $y_{k+1}$~--- свободные, а все остальные вершины насыщенные в паросочетании $M$, причем каждое второе ребро принадлежит $M$ (т.е. ребра вида $y_ix_{i+1}, i=1,\ldots,k-1$ входят в $M$), а остальные ребра в $M$ не входят.

Операция $M\oplus P$ определяется следующим образом: \textit{все ребра из $P$, входившие в $M$ из паросочетания исключаются, а все ребра из $P$, не входившие в $M$, в паросочетание добавляются}. Другими словами,
$$
  M\oplus P=(M\backslash P)\cup(P\backslash M).
$$
В цепи $P$ происходит <<переключение цветов>>: светлые ребра становятся темными и, наоборот, темные~--- светлыми.

\subsubsection{Алгоритм Куна}
Поиск максимального (и полного) парасочетания.
\begin{enumerate}
\item пустое паросочетание объявить текущим паросочетанием $M$;
\item если все вершины из $X$ насыщены в $M$, то СТОП ($M$~--- полное паросочетание);
\item иначе выбрать произвольную свободную вершину $x\in X$ и искать $M$--чередующуюся цепь, начинающуюся в $x$;

\item если такая цепь $P$ найдена, то положить $M:=M\oplus P$ и вернуться на шаг 2;

\item иначе СТОП (полного паросочетания в заданном графе не существует).
\end{enumerate}

\subsection{Задача о назначениях}

Пусть $G=(X,Y,E,c)$~--- взвешенный двудольный граф, \linebreak $|X|=|Y|=n$.

\textbf{Весом} паросочетания $M$ называется сумма весов входящих в него 

\textbf{Задача о назначениях:} в заданном взвешенном двудольном графе найти полное паросочетание минимального веса (\textbf{оптимальное паросочетание}).

Если веса всех ребер графа, инцидентных какой-либо вершине, увеличить (уменьшить) на одно и то же число, то всякое оптимальное паросочетание в графе с новыми весами является оптимальным и в графе с исходными весами

Пусть $X' \subseteq X$, $Y'\subseteq Y$ и $d\in R$. Будем говорить, что к графу $G=(X,Y,E,c)$ применена операция $\mathbf{(X',d,Y')}$, если сначала из веса каждого ребра, инцидентного вершине из $X’$, вычтено число $d$, а затем к весу каждого ребра, инцидентного вершине из $Y'$, прибавлено число $d$.

Схема применения операции:

\begin{center}
\begin{tabular}{|c||c|c|}
\hline
&$Y'$&$Y\backslash Y'$\\
\hline\hline
$X'$&$I$&$II-d$\\
\hline
$X\backslash X'$&$IV+d$&$III$\\
\hline
\end{tabular}
\end{center}

\subsubsection{Венгерский алгоритм}
\begin{enumerate}
\item Преобразовать веса ребер так, чтобы веса всех ребер стали неотрицательными и каждой вершине стало инцидентно хотя бы одно ребро нулевого веса;

\item пустое паросочетание объявить текущим паросочетанием $M$;

\item если в графе все вершины насыщены относительно текущего паросочетания, то СТОП (текущее паросочетание оптимально);

\item иначе выбрать свободную вершину $x\in X$ и искать $M$--чере\-ду\-ющую\-ся цепь, начинающуюся в $X$, из ребер нулевого веса;

\item если такая цепь построена, то положить $M:=M\oplus P$ и вернуться на шаг 3;

\item иначе для множества вершин $X’\subseteq X$, $Y’\subseteq Y$, помеченных в ходе поиска (это вершины венгерского дерева), положить величину $d$ равной $\min\{c(x,y)|x\in X’, y\in Y\backslash Y’\}$ и применить к графу операцию $(X’,d,Y’)$;

\item из тех вершин $x\in X’$, которым стало инцидентно хотя бы одно ребро нулевого веса, возобновить поиск $M$--чередующейся цепи по ребрам нулевого веса; если такая цепь $P$ будет найдена, то положить $M:=M\oplus P$ и вернуться на шаг 3; иначе вернуться на шаг 6  (множества $X’$ и $Y’$ при этом увеличатся).
\end{enumerate}